## 9/4/2025

[Schedule](https://rustconf.com/schedule/#thursday)

### This Week in Rust: Ten Years of Learning Together 9:05 \- 3:35am

* [https://this-week-in-rust.org/](https://this-week-in-rust.org/)
* Changes to rust follow the Rust RFC
* [Create of the week](https://this-week-in-rust.org/blog/2025/09/03/this-week-in-rust-615/#crate-of-the-week)
* Rustacean Connections


### Verifying Memory Safety for the Rust Standard Library 9:40 \- 9:50am

* Rust is easier to formally verify than other languages – it has “formal verification” built into it (didn’t provide details about this, we would like to learn more)
*  Verification \-\> Create a contest:
  * Challenge \-\> Goal:
    * Motivation \-
    * success criteria
  * Solution \-\>
  * Technical review \-\>
  * Rewards committee
*  [Contest challenges are on their github](https://github.com/model-checking/verify-rust-std/issues)
  * Each challenge lists the goal, success criteria, and motivation
  * Most of the motivations are based on previous problems that people have found
* There are now 4 tools (kani, flux, ) that you can use to formally verify Rust created through this contest (another coming soon)
* 7 Challenges have been solved\! Covering 37% of the library
* [https://github.com/model-checking/verify-rust-std](https://github.com/model-checking/verify-rust-std)
* [Book about the challenge](https://model-checking.github.io/verify-rust-std/intro.html)

### How We Made the Rust CI 75% Cheaper 10:20 \- 10:50am

* Two CI setups: PR builds (provides fast feedback to the contributor with parallel checks) and auto build (slower, it is 150 hours\! the checks are sequential)
* Every month, the rust organization uses 6 years of CPU time for CI\!
* 3 constraints. First is time. Second resources. Third is the cost.
* Goal: move from expensive Large CI runners to free Standard runners
* Since the slowest job is already a bottleneck, there is no need to run fast jobs on Large runners (they will have to wait for the slow job anyway)
  * These over provisioned jobs happened over time – for example, the longest runner is 3 hours now, but 2 years ago, it was only 2 hours (less of a bottleneck)
*  Freeing disk space, since github runners come pre-installed with a bunch of tools that aren’t actually needed for the tests (web browsers, etc.)
*  Optimizations \-\> splitting jobs
  * Analyzed how much time jobs took between build artifacts and tests
  * Split tests. Build artifacts more than once but tests is splitted. (one improvement)
  * One build artifact, uploads artifacts \-\> additional latency that takes time to compress the artifacts (last improvement)
  * Result \-\> 3 large runners were improved
* Moving to ARM runners
* AWS Codebuild \- alternative to Github large runners. Runs on codebuild-ubuntu
* [github.com/rust-lang/ci-feedback](http://github.com/rust-lang/ci-feedback)

### 10 Years of Redox OS and Rust 10:55am \- 11:25am

* [Redox OS](https://www.redox-os.org/)
* Relibc \- C library written in rust
* Redox as a container Host
  * Lightweight but secure containers as a first goal
  * capability \-based security provides abstraction for POSIX file descriptors
* Redox \- as a safe runtime for Cloud Applications
* Desktop Redox
* Performance
* https://doc.redox-os.org/book/chat.html

### Secure Messaging: Leveraging Rust to Create the Guardian’s Anonymous Whistleblowing System  12:40pm \- 1:20pm

* AWS Kinesis
* Decision: should we use “Blazingly fast” rust or “Easy mode” rust
  * “Easy mode” rust: idea from [Andre Bogus talk](https://www.youtube.com/watch?v=33FG6O3qejM).  Don’t worry about minimizing every possible memory allocation, store owned objects in structs, etc.  Makes the code a lot more approachable to people new to Rust.
  * They chose to do a blend of the approaches.
* Type system and NewType pattern were very useful
* Type state pattern prevents them from using the wrong type of cryptographic key at any time
* Testing and observability
  * TestContainers.
  * Time travel. Assertion for the state of the system and through time. Time module
  * Observability: Metrics \-\> amazon \-\> Grafana
* [coverdrop.org](http://coverdrop.org)


### Scaling a Rust community: Lessons from the Frontlines 1:30pm \- 2:10pm

* Wojciech Kargul	
* Building from ground up
  * Be visible, inclusive
  * Lower the barrier
  * Partner early \- reach out to universities , students
  * Listen to people ,ask questions
*  Keeping the momentum
  * Consistency
  * Rotation of voices
  * Feedback loop
  * Micro engagement
*  Beyond the Meetup
  * Hands on workshops
  * Open source projects
  * University collaborations
  * Hackathons
  * Sponsors
*  Lessons from the frontlines:
  * Small frequent events bear big
  * Empowering members to contribute
* What didn’t work
  * Overloading the calendar too soon
  * Not having a backup speaker
  * Assuming sponsors will just appear.
* Diverse audience
  * Make the speaker aware of the topics
  * Make the topics desirable for  the audience
* Frequency and group size
  * In person every two months is good
* Sponsors


### Auto \- Instrumenting Rust Applications Using eBPF and Open Telemetry

*  Why auto instrumentation?
  * Legacy systems
  * Large codebases
  * Cross-language distributed systems
*  Rust ecosystem for eBPF development
  * Aya
    * Rust implementation
  * Libpf-rs
    * Rust wrapper around c library


### Cancelling Async Rust 2:35pm \- 3:15pm

*  Cancellations: an important part of async rust, but can be difficult to reason about
* Example: you are sending messages to a channel, add a timeout, and want to handle the errors
* Options to cancel:
  * Panic
    * Some compilation targets like WASM cant catch panics
  * Stop the process
    * Heavy handed but effective
  * Stop the thread
    * Not allowed in safe rust
*  Futures do nothing unless you await them
  * This is diametrically opposed to a Promise in javascript – in js, it goes off and does its work regardless of if you await it
*  This means that you can cancel any future any time you would await
  * This makes it easy\!  But this is a double-edged sword.  You have to keep in mind that if you cancel a Future, it also propagates to the child Futures of that Future
    * (It makes sense to me)
* Cancel safety: you will see this in tokio documentation.  If you cancel a Future, it will not have side effects
* Tokio mutexes: an example of an API that is very susceptible to cancellation bugs
  * Better to avoid them if possible
* Tokio select \- good way to cancel
  * Returns the first future to complete and cancels the rest


### Vision Doc: The Next 10 Years of Rust

*  They did a survey of rust users
* Live interviews of users
* Some areas where rust could be improved were found
  * As rust keeps the standard library small some users were confused by the documentation since most people use a library. Ex trying to use \`result\` when everyone used `anyhow`
* Adoption driven multiple ways
  * Many people reported “bouncing off” their first try
    * Possible that improvements to Rust since initial development made second attempt more successful
  * Availability of university courses major driver of adoption outside US and EU
